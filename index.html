<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Audio Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap');
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    color: white;
    font-family: "Lato", sans-serif;
  }
  canvas {
    display: block;
    cursor: pointer;
  }
  #controls {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 8px;
    transition: opacity 0.5s;
  }
  button, input[type="range"], input[type="file"] {
    margin: 4px;
    padding: 6px 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    color: white;
  }
  button:hover {
    background: rgba(255,255,255,0.2);
  }
  label { font-size: 14px; }
  .name {
    position: absolute;
    right: 10px;
    font-size: 18px;
    font-weight: bold;
    font-family: "Lato", sans-serif;
    color: white;
  }
</style>
</head>
<body>
  <h1 class="name">Drexyl</h1>
<div id="controls">
  <input type="file" id="fileInput" accept="audio/*"><br>
  <button id="playBtn" disabled>Play</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="modeBtn" disabled>Switch Mode</button><br>
  <label>Bar Height: <input type="range" id="heightSlider" min="0.5" max="5" value="5" step="0.1"></label><br>
  <label>Bar Count: <input type="range" id="barSlider" min="1" max="2048" value="353" step="16"></label>
</div>
<canvas id="visualizer"></canvas>

<script>
const canvas = document.getElementById("visualizer");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let audioContext, analyser, dataArray, bufferLength, source;
let audio;
let mode = "both";
let barScale = 5;
let barCount = 353; // default

const controls = document.getElementById("controls");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");
const stopBtn = document.getElementById("stopBtn");
const modeBtn = document.getElementById("modeBtn");
const heightSlider = document.getElementById("heightSlider");
const barSlider = document.getElementById("barSlider");

// --- Audio file input ---
document.getElementById("fileInput").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;

  if (audio) { audio.pause(); audio.remove(); }

  audio = new Audio();
  audio.src = URL.createObjectURL(file);
  audio.controls = false;
  audio.autoplay = true;
  document.body.appendChild(audio);
  audio.style.display = "none";

  if (!audioContext) { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }

  source = audioContext.createMediaElementSource(audio);
  analyser = audioContext.createAnalyser();
  source.connect(analyser);
  analyser.connect(audioContext.destination);

  analyser.fftSize = 2048;
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);

  playBtn.disabled = false;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
  modeBtn.disabled = false;

  draw();
});

// --- Controls ---
playBtn.addEventListener("click", () => { if(audioContext.state==="suspended") audioContext.resume(); audio.play(); });
pauseBtn.addEventListener("click", () => audio.pause());
stopBtn.addEventListener("click", () => { audio.pause(); audio.currentTime=0; });
modeBtn.addEventListener("click", () => {
    if (mode === "frequency") mode = "waveform";
    else if (mode === "waveform") mode = "both";
    else mode = "frequency";
  });
heightSlider.addEventListener("input", () => barScale = parseFloat(heightSlider.value));
barSlider.addEventListener("input", () => barCount = parseInt(barSlider.value));

// --- Keyboard shortcuts ---
document.addEventListener("keydown", (e) => {
  if (!audio) return;
  if (e.code === "Space") { e.preventDefault(); audio.paused ? audio.play() : audio.pause(); }
  else if (e.key.toLowerCase() === "r") { audio.currentTime=0; audio.pause(); }
  else if (e.key.toLowerCase() === "s") {
    if (mode === "frequency") mode = "waveform";
    else if (mode === "waveform") mode = "both";
    else mode = "frequency";
  }
});

// --- Fullscreen toggle ---
canvas.addEventListener("click", () => {
  if (!document.fullscreenElement) { canvas.requestFullscreen().catch(err=>console.log(err)); }
  else { document.exitFullscreen(); }
});

// --- Fade controls and hide cursor in fullscreen ---
document.addEventListener("fullscreenchange", () => {
  if (document.fullscreenElement) {
    controls.style.opacity = 0;
    canvas.style.cursor = "none";
  } else {
    controls.style.opacity = 1;
    canvas.style.cursor = "pointer";
  }
});

// --- Draw visualizer ---
function draw() {
  requestAnimationFrame(draw);
  if (!analyser) return;

  // Draw a semi-transparent black rectangle for fading effect
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (mode === "frequency") {
    analyser.getByteFrequencyData(dataArray);

    // --- Ignore frequencies above 10kHz ---
    const sampleRate = audioContext.sampleRate;
    const nyquist = sampleRate / 2;
    const maxFrequency = 15000;
    const maxBin = Math.floor((maxFrequency / nyquist) * bufferLength);

    const effectiveBarCount = Math.min(barCount, maxBin); // clamp bar count
    const step = Math.max(1, Math.floor(maxBin / effectiveBarCount));
    const spacing = 0;
    const barWidth = (canvas.width - (effectiveBarCount-1)*spacing)/effectiveBarCount;
    let x = 0;

    for(let i=0;i<effectiveBarCount;i++){
      const amplitude = dataArray[i*step] || 0;
      const boost = 0.8 + 0.2*(i/effectiveBarCount); // high freq boost
      const loudness = amplitude * boost;

      const barHeight = loudness * barScale;
      const hue = (i/effectiveBarCount)*360;
      const alpha = Math.min(1, amplitude/255);

      ctx.fillStyle = `hsla(${hue},100%,50%,${alpha})`;
      ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
      x += barWidth + spacing;
    }

  } else if (mode === "waveform") {
    analyser.getByteTimeDomainData(dataArray);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgb(0,200,255)";
    ctx.beginPath();
    const sliceWidth = canvas.width / bufferLength;
    let x = 0;
    for(let i=0;i<bufferLength;i++){
      const v = dataArray[i]/128.0;
      const waveformScale = 0.3; // 30% of canvas height
      const y = canvas.height/2 + (v-1) * canvas.height * waveformScale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      x+=sliceWidth;
    }
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.stroke();
  }
  else {
    analyser.getByteFrequencyData(dataArray);

    // --- Ignore frequencies above 10kHz ---
    const sampleRate = audioContext.sampleRate;
    const nyquist = sampleRate / 2;
    const maxFrequency = 15000;
    const maxBin = Math.floor((maxFrequency / nyquist) * bufferLength);

    const effectiveBarCount = Math.min(barCount, maxBin); // clamp bar count
    const step = Math.max(1, Math.floor(maxBin / effectiveBarCount));
    const spacing = 0;
    const barWidth = (canvas.width - (effectiveBarCount-1)*spacing)/effectiveBarCount;
    let x = 0;

    for(let i=0;i<effectiveBarCount;i++){
      const amplitude = dataArray[i*step] || 0;
      const boost = 0.8 + 0.2*(i/effectiveBarCount); // high freq boost
      const loudness = amplitude * boost;

      const barHeight = loudness * barScale;
      const hue = (i/effectiveBarCount)*360;
      const alpha = Math.min(1, amplitude/255);

      ctx.fillStyle = `hsla(${hue},100%,50%,${alpha})`;
      ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
      x += barWidth + spacing;
    }
    analyser.getByteTimeDomainData(dataArray);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgb(0,200,255)";
    ctx.beginPath();
    const sliceWidth = canvas.width / bufferLength;
    x = 0;
    for(let i=0;i<bufferLength;i++){
      const v = dataArray[i]/128.0;
      const waveformScale = 0.3; // 30% of canvas height
      const y = canvas.height/4 + (v-1) * canvas.height * waveformScale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      x+=sliceWidth;
    }
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.stroke();
  }
}

window.addEventListener("resize", ()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>
</body>
</html>
